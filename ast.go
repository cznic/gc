// CAUTION: Generated by yy - DO NOT EDIT.

// Copyright 2016 The GC Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gc

import (
	"go/token"

	"github.com/cznic/xc"
)

// Argument represents data reduced by productions:
//
//	Argument:
//	        Expression
//	|       TypeLiteral  // Case 1
type Argument struct {
	Value       Value
	Case        int
	Expression  *Expression
	TypeLiteral *TypeLiteral
}

func (n *Argument) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Argument) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Argument) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.Expression.Pos()
	case 1:
		return n.TypeLiteral.Pos()
	default:
		panic("internal error")
	}
}

// ArgumentList represents data reduced by productions:
//
//	ArgumentList:
//	        Argument
//	|       ArgumentList ',' Argument  // Case 1
type ArgumentList struct {
	Argument     *Argument
	ArgumentList *ArgumentList
	Case         int
	Token        xc.Token
}

func (n *ArgumentList) reverse() *ArgumentList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ArgumentList
	for nb != nil {
		nc := nb.ArgumentList
		nb.ArgumentList = na
		na = nb
		nb = nc
	}
	n.ArgumentList = nil
	return na
}

func (n *ArgumentList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ArgumentList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ArgumentList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.Argument.Pos()
	case 1:
		return n.ArgumentList.Pos()
	default:
		panic("internal error")
	}
}

// ArrayType represents data reduced by productions:
//
//	ArrayType:
//	        '[' "..." ']' Typ
//	|       '[' Expression ']' Typ  // Case 1
type ArrayType struct {
	Type       Type
	guard      gate
	items      int64
	Case       int
	Expression *Expression
	Token      xc.Token
	Token2     xc.Token
	Token3     xc.Token
	Typ        *Typ
}

func (n *ArrayType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ArrayType) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ArrayType) Pos() token.Pos {
	return n.Token.Pos()
}

// Assignment represents data reduced by productions:
//
//	Assignment:
//	        ExpressionList '=' ExpressionList
//	|       ExpressionList "+=" ExpressionList   // Case 1
//	|       ExpressionList "&^=" ExpressionList  // Case 2
//	|       ExpressionList "&=" ExpressionList   // Case 3
//	|       ExpressionList "/=" ExpressionList   // Case 4
//	|       ExpressionList "<<=" ExpressionList  // Case 5
//	|       ExpressionList "%=" ExpressionList   // Case 6
//	|       ExpressionList "*=" ExpressionList   // Case 7
//	|       ExpressionList "|=" ExpressionList   // Case 8
//	|       ExpressionList ">>=" ExpressionList  // Case 9
//	|       ExpressionList "-=" ExpressionList   // Case 10
//	|       ExpressionList "^=" ExpressionList   // Case 11
type Assignment struct {
	Case            int
	ExpressionList  *ExpressionList
	ExpressionList2 *ExpressionList
	Token           xc.Token
}

func (n *Assignment) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Assignment) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Assignment) Pos() token.Pos {
	return n.ExpressionList.Pos()
}

// BasicLiteral represents data reduced by productions:
//
//	BasicLiteral:
//	        CHAR_LIT
//	|       FLOAT_LIT   // Case 1
//	|       IMAG_LIT    // Case 2
//	|       INT_LIT     // Case 3
//	|       STRING_LIT  // Case 4
type BasicLiteral struct {
	Value       Value
	stringValue stringValue
	Case        int
	Token       xc.Token
}

func (n *BasicLiteral) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *BasicLiteral) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *BasicLiteral) Pos() token.Pos {
	return n.Token.Pos()
}

// Block represents data reduced by production:
//
//	Block:
//	        '{' StatementList '}'
type Block struct {
	StatementList *StatementList
	Token         xc.Token
	Token2        xc.Token
}

func (n *Block) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Block) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Block) Pos() token.Pos {
	return n.Token.Pos()
}

// Body represents data reduced by production:
//
//	Body:
//	        BODY StatementList '}'
type Body struct {
	StatementList *StatementList
	Token         xc.Token
	Token2        xc.Token
}

func (n *Body) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Body) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Body) Pos() token.Pos {
	return n.Token.Pos()
}

// Call represents data reduced by productions:
//
//	Call:
//	        '(' ')'
//	|       '(' ArgumentList CommaOpt ')'        // Case 1
//	|       '(' ArgumentList "..." CommaOpt ')'  // Case 2
type Call struct {
	ArgumentList *ArgumentList
	Case         int
	CommaOpt     *CommaOpt
	Token        xc.Token
	Token2       xc.Token
	Token3       xc.Token
}

func (n *Call) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Call) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Call) Pos() token.Pos {
	return n.Token.Pos()
}

// ChanType represents data reduced by productions:
//
//	ChanType:
//	        "chan" Typ
//	|       "chan" TXCHAN Typ  // Case 1
//	|       RXCHAN "chan" Typ  // Case 2
type ChanType struct {
	guard  gate
	Type   Type
	Case   int
	Token  xc.Token
	Token2 xc.Token
	Typ    *Typ
}

func (n *ChanType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ChanType) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ChanType) Pos() token.Pos {
	return n.Token.Pos()
}

// CommaOpt represents data reduced by productions:
//
//	CommaOpt:
//	        /* empty */
//	|       ','          // Case 1
type CommaOpt struct {
	Token xc.Token
}

func (n *CommaOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *CommaOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *CommaOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// CompLitItem represents data reduced by productions:
//
//	CompLitItem:
//	        CompLitValue
//	|       CompLitValue ':' CompLitValue  // Case 1
//	|       CompLitValue ':' Expression    // Case 2
//	|       Expression                     // Case 3
//	|       Expression ':' CompLitValue    // Case 4
//	|       Expression ':' Expression      // Case 5
type CompLitItem struct {
	Case          int
	CompLitValue  *CompLitValue
	CompLitValue2 *CompLitValue
	Expression    *Expression
	Expression2   *Expression
	Token         xc.Token
}

func (n *CompLitItem) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *CompLitItem) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *CompLitItem) Pos() token.Pos {
	switch n.Case {
	case 0, 1, 2:
		return n.CompLitValue.Pos()
	case 3, 4, 5:
		return n.Expression.Pos()
	default:
		panic("internal error")
	}
}

// CompLitItemList represents data reduced by productions:
//
//	CompLitItemList:
//	        CompLitItem
//	|       CompLitItemList ',' CompLitItem  // Case 1
type CompLitItemList struct {
	Case            int
	CompLitItem     *CompLitItem
	CompLitItemList *CompLitItemList
	Token           xc.Token
}

func (n *CompLitItemList) reverse() *CompLitItemList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.CompLitItemList
	for nb != nil {
		nc := nb.CompLitItemList
		nb.CompLitItemList = na
		na = nb
		nb = nc
	}
	n.CompLitItemList = nil
	return na
}

func (n *CompLitItemList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *CompLitItemList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *CompLitItemList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.CompLitItem.Pos()
	case 1:
		return n.CompLitItemList.Pos()
	default:
		panic("internal error")
	}
}

// CompLitType represents data reduced by productions:
//
//	CompLitType:
//	        ArrayType
//	|       MapType     // Case 1
//	|       SliceType   // Case 2
//	|       StructType  // Case 3
type CompLitType struct {
	guard      gate
	Type       Type
	ArrayType  *ArrayType
	Case       int
	MapType    *MapType
	SliceType  *SliceType
	StructType *StructType
}

func (n *CompLitType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *CompLitType) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *CompLitType) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.ArrayType.Pos()
	case 1:
		return n.MapType.Pos()
	case 2:
		return n.SliceType.Pos()
	case 3:
		return n.StructType.Pos()
	default:
		panic("internal error")
	}
}

// CompLitValue represents data reduced by productions:
//
//	CompLitValue:
//	        '{' '}'
//	|       '{' CompLitItemList CommaOpt '}'  // Case 1
type CompLitValue struct {
	Type            Type
	items           int64
	Case            int
	CommaOpt        *CommaOpt
	CompLitItemList *CompLitItemList
	Token           xc.Token
	Token2          xc.Token
}

func (n *CompLitValue) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *CompLitValue) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *CompLitValue) Pos() token.Pos {
	return n.Token.Pos()
}

// ConstDecl represents data reduced by productions:
//
//	ConstDecl:
//	        "const" '(' ')'
//	|       "const" '(' ConstSpecList SemicolonOpt ')'  // Case 1
//	|       "const" ConstSpec                           // Case 2
type ConstDecl struct {
	Case          int
	ConstSpec     *ConstSpec
	ConstSpecList *ConstSpecList
	SemicolonOpt  *SemicolonOpt
	Token         xc.Token
	Token2        xc.Token
	Token3        xc.Token
}

func (n *ConstDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ConstDecl) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ConstDecl) Pos() token.Pos {
	return n.Token.Pos()
}

// ConstSpec represents data reduced by productions:
//
//	ConstSpec:
//	        IdentifierList
//	|       IdentifierList '=' ExpressionList      // Case 1
//	|       IdentifierList Typ '=' ExpressionList  // Case 2
type ConstSpec struct {
	Case           int
	ExpressionList *ExpressionList
	IdentifierList *IdentifierList
	Token          xc.Token
	Typ            *Typ
}

func (n *ConstSpec) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ConstSpec) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ConstSpec) Pos() token.Pos {
	return n.IdentifierList.Pos()
}

// ConstSpecList represents data reduced by productions:
//
//	ConstSpecList:
//	        ConstSpec
//	|       ConstSpecList ';' ConstSpec  // Case 1
type ConstSpecList struct {
	Case          int
	ConstSpec     *ConstSpec
	ConstSpecList *ConstSpecList
	Token         xc.Token
}

func (n *ConstSpecList) reverse() *ConstSpecList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ConstSpecList
	for nb != nil {
		nc := nb.ConstSpecList
		nb.ConstSpecList = na
		na = nb
		nb = nc
	}
	n.ConstSpecList = nil
	return na
}

func (n *ConstSpecList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ConstSpecList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ConstSpecList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.ConstSpec.Pos()
	case 1:
		return n.ConstSpecList.Pos()
	default:
		panic("internal error")
	}
}

// Elif represents data reduced by production:
//
//	Elif:
//	        "else" "if" IfHeader Body
type Elif struct {
	Body     *Body
	IfHeader *IfHeader
	Token    xc.Token
	Token2   xc.Token
}

func (n *Elif) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Elif) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Elif) Pos() token.Pos {
	return n.Token.Pos()
}

// ElifList represents data reduced by productions:
//
//	ElifList:
//	        /* empty */
//	|       ElifList Elif  // Case 1
type ElifList struct {
	Elif     *Elif
	ElifList *ElifList
}

func (n *ElifList) reverse() *ElifList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ElifList
	for nb != nil {
		nc := nb.ElifList
		nb.ElifList = na
		na = nb
		nb = nc
	}
	n.ElifList = nil
	return na
}

func (n *ElifList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ElifList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ElifList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	if p := n.ElifList.Pos(); p != 0 {
		return p
	}

	return n.Elif.Pos()
}

// ElseOpt represents data reduced by productions:
//
//	ElseOpt:
//	        /* empty */
//	|       "else" Block  // Case 1
type ElseOpt struct {
	Block *Block
	Token xc.Token
}

func (n *ElseOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ElseOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ElseOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// Expression represents data reduced by productions:
//
//	Expression:
//	        UnaryExpression
//	|       Expression '%' Expression   // Case 1
//	|       Expression '&' Expression   // Case 2
//	|       Expression '*' Expression   // Case 3
//	|       Expression '+' Expression   // Case 4
//	|       Expression '-' Expression   // Case 5
//	|       Expression '/' Expression   // Case 6
//	|       Expression '<' Expression   // Case 7
//	|       Expression '>' Expression   // Case 8
//	|       Expression '^' Expression   // Case 9
//	|       Expression '|' Expression   // Case 10
//	|       Expression "&&" Expression  // Case 11
//	|       Expression "&^" Expression  // Case 12
//	|       Expression "==" Expression  // Case 13
//	|       Expression ">=" Expression  // Case 14
//	|       Expression "<=" Expression  // Case 15
//	|       Expression "<<" Expression  // Case 16
//	|       Expression "!=" Expression  // Case 17
//	|       Expression "||" Expression  // Case 18
//	|       Expression ">>" Expression  // Case 19
//	|       Expression "<-" Expression  // Case 20
type Expression struct {
	Value           Value
	Case            int
	Expression      *Expression
	Expression2     *Expression
	Token           xc.Token
	UnaryExpression *UnaryExpression
}

func (n *Expression) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Expression) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Expression) Pos() token.Pos {
	switch n.Case {
	case 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20:
		return n.Expression.Pos()
	case 0:
		return n.UnaryExpression.Pos()
	default:
		panic("internal error")
	}
}

// ExpressionList represents data reduced by productions:
//
//	ExpressionList:
//	        Expression
//	|       ExpressionList ',' Expression  // Case 1
type ExpressionList struct {
	Case           int
	Expression     *Expression
	ExpressionList *ExpressionList
	Token          xc.Token
}

func (n *ExpressionList) reverse() *ExpressionList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ExpressionList
	for nb != nil {
		nc := nb.ExpressionList
		nb.ExpressionList = na
		na = nb
		nb = nc
	}
	n.ExpressionList = nil
	return na
}

func (n *ExpressionList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ExpressionList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ExpressionList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.Expression.Pos()
	case 1:
		return n.ExpressionList.Pos()
	default:
		panic("internal error")
	}
}

// ExpressionListOpt represents data reduced by productions:
//
//	ExpressionListOpt:
//	        /* empty */
//	|       ExpressionList  // Case 1
type ExpressionListOpt struct {
	ExpressionList *ExpressionList
}

func (n *ExpressionListOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ExpressionListOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ExpressionListOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.ExpressionList.Pos()
}

// ExpressionOpt represents data reduced by productions:
//
//	ExpressionOpt:
//	        /* empty */
//	|       Expression   // Case 1
type ExpressionOpt struct {
	Expression *Expression
}

func (n *ExpressionOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ExpressionOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ExpressionOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Expression.Pos()
}

// File represents data reduced by production:
//
//	File:
//	        Prologue TopLevelDeclList
type File struct {
	DotImports       []*ImportDeclaration // import . "foo"
	UnboundImports   []*ImportDeclaration // import _ "foo"
	Scope            *Scope               // import "foo" and import foo "bar"
	Path             string               // The source file path.
	Prologue         *Prologue
	TopLevelDeclList *TopLevelDeclList
}

func (n *File) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *File) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *File) Pos() token.Pos {
	return n.Prologue.Pos()
}

// ForHeader represents data reduced by productions:
//
//	ForHeader:
//	        Range
//	|       SimpleStatementOpt ';' SimpleStatementOpt ';' SimpleStatementOpt  // Case 1
//	|       SimpleStatementOpt                                                // Case 2
type ForHeader struct {
	Case                int
	Range               *Range
	SimpleStatementOpt  *SimpleStatementOpt
	SimpleStatementOpt2 *SimpleStatementOpt
	SimpleStatementOpt3 *SimpleStatementOpt
	Token               xc.Token
	Token2              xc.Token
}

func (n *ForHeader) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ForHeader) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ForHeader) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.Range.Pos()
	case 2:
		return n.SimpleStatementOpt.Pos()
	case 1:
		if p := n.SimpleStatementOpt.Pos(); p != 0 {
			return p
		}

		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// ForStatement represents data reduced by production:
//
//	ForStatement:
//	        "for" ForHeader Body
type ForStatement struct {
	Body      *Body
	ForHeader *ForHeader
	Token     xc.Token
}

func (n *ForStatement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ForStatement) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ForStatement) Pos() token.Pos {
	return n.Token.Pos()
}

// FuncBodyOpt represents data reduced by productions:
//
//	FuncBodyOpt:
//	        /* empty */
//	|       Block        // Case 1
type FuncBodyOpt struct {
	Block *Block
}

func (n *FuncBodyOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *FuncBodyOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *FuncBodyOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Block.Pos()
}

// FuncDecl represents data reduced by production:
//
//	FuncDecl:
//	        "func" ReceiverOpt IDENTIFIER GenericParametersOpt Signature FuncBodyOpt
type FuncDecl struct {
	FuncBodyOpt          *FuncBodyOpt
	GenericParametersOpt *GenericParametersOpt
	ReceiverOpt          *ReceiverOpt
	Signature            *Signature
	Token                xc.Token
	Token2               xc.Token
}

func (n *FuncDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *FuncDecl) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *FuncDecl) Pos() token.Pos {
	return n.Token.Pos()
}

// FuncType represents data reduced by productions:
//
//	FuncType:
//	        "func" Signature
//	|       "func" "«" IdentifierList "»" Signature  // Case 1
type FuncType struct {
	guard          gate
	Type           Type
	Case           int
	IdentifierList *IdentifierList
	Signature      *Signature
	Token          xc.Token
	Token2         xc.Token
	Token3         xc.Token
}

func (n *FuncType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *FuncType) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *FuncType) Pos() token.Pos {
	return n.Token.Pos()
}

// GenericArgumentsOpt represents data reduced by productions:
//
//	GenericArgumentsOpt:
//	        /* empty */
//	|       "«" TypeList "»"  // Case 1
type GenericArgumentsOpt struct {
	Token    xc.Token
	Token2   xc.Token
	TypeList *TypeList
}

func (n *GenericArgumentsOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *GenericArgumentsOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *GenericArgumentsOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// GenericParametersOpt represents data reduced by productions:
//
//	GenericParametersOpt:
//	        /* empty */
//	|       "«" IdentifierList "»"  // Case 1
type GenericParametersOpt struct {
	IdentifierList *IdentifierList
	Token          xc.Token
	Token2         xc.Token
}

func (n *GenericParametersOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *GenericParametersOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *GenericParametersOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// IdentifierList represents data reduced by productions:
//
//	IdentifierList:
//	        IDENTIFIER
//	|       IdentifierList ',' IDENTIFIER  // Case 1
type IdentifierList struct {
	Case           int
	IdentifierList *IdentifierList
	Token          xc.Token
	Token2         xc.Token
}

func (n *IdentifierList) reverse() *IdentifierList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.IdentifierList
	for nb != nil {
		nc := nb.IdentifierList
		nb.IdentifierList = na
		na = nb
		nb = nc
	}
	n.IdentifierList = nil
	return na
}

func (n *IdentifierList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *IdentifierList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *IdentifierList) Pos() token.Pos {
	switch n.Case {
	case 1:
		return n.IdentifierList.Pos()
	case 0:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// IdentifierOpt represents data reduced by productions:
//
//	IdentifierOpt:
//	        /* empty */
//	|       IDENTIFIER   // Case 1
type IdentifierOpt struct {
	Token xc.Token
}

func (n *IdentifierOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *IdentifierOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *IdentifierOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// IfHeader represents data reduced by productions:
//
//	IfHeader:
//	        SimpleStatementOpt
//	|       SimpleStatementOpt ';' SimpleStatementOpt  // Case 1
type IfHeader struct {
	Case                int
	SimpleStatementOpt  *SimpleStatementOpt
	SimpleStatementOpt2 *SimpleStatementOpt
	Token               xc.Token
}

func (n *IfHeader) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *IfHeader) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *IfHeader) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.SimpleStatementOpt.Pos()
	case 1:
		if p := n.SimpleStatementOpt.Pos(); p != 0 {
			return p
		}

		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// IfStatement represents data reduced by production:
//
//	IfStatement:
//	        "if" IfHeader Body ElifList ElseOpt
type IfStatement struct {
	Body     *Body
	ElifList *ElifList
	ElseOpt  *ElseOpt
	IfHeader *IfHeader
	Token    xc.Token
}

func (n *IfStatement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *IfStatement) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *IfStatement) Pos() token.Pos {
	return n.Token.Pos()
}

// ImportDecl represents data reduced by productions:
//
//	ImportDecl:
//	        "import" '(' ')'
//	|       "import" '(' ImportSpecList SemicolonOpt ')'  // Case 1
//	|       "import" ImportSpec                           // Case 2
type ImportDecl struct {
	Case           int
	ImportSpec     *ImportSpec
	ImportSpecList *ImportSpecList
	SemicolonOpt   *SemicolonOpt
	Token          xc.Token
	Token2         xc.Token
	Token3         xc.Token
}

func (n *ImportDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ImportDecl) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ImportDecl) Pos() token.Pos {
	return n.Token.Pos()
}

// ImportList represents data reduced by productions:
//
//	ImportList:
//	        /* empty */
//	|       ImportList ImportDecl ';'  // Case 1
type ImportList struct {
	ImportDecl *ImportDecl
	ImportList *ImportList
	Token      xc.Token
}

func (n *ImportList) reverse() *ImportList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ImportList
	for nb != nil {
		nc := nb.ImportList
		nb.ImportList = na
		na = nb
		nb = nc
	}
	n.ImportList = nil
	return na
}

func (n *ImportList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ImportList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ImportList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	if p := n.ImportList.Pos(); p != 0 {
		return p
	}

	return n.ImportDecl.Pos()
}

// ImportSpec represents data reduced by productions:
//
//	ImportSpec:
//	        '.' BasicLiteral
//	|       IdentifierOpt BasicLiteral        // Case 1
//	|       '.' BasicLiteral error            // Case 2
//	|       IdentifierOpt BasicLiteral error  // Case 3
type ImportSpec struct {
	BasicLiteral  *BasicLiteral
	Case          int
	IdentifierOpt *IdentifierOpt
	Token         xc.Token
	Token2        xc.Token
}

func (n *ImportSpec) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ImportSpec) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ImportSpec) Pos() token.Pos {
	switch n.Case {
	case 1, 3:
		if p := n.IdentifierOpt.Pos(); p != 0 {
			return p
		}

		return n.BasicLiteral.Pos()
	case 0, 2:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// ImportSpecList represents data reduced by productions:
//
//	ImportSpecList:
//	        ImportSpec
//	|       ImportSpecList ';' ImportSpec  // Case 1
type ImportSpecList struct {
	Case           int
	ImportSpec     *ImportSpec
	ImportSpecList *ImportSpecList
	Token          xc.Token
}

func (n *ImportSpecList) reverse() *ImportSpecList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ImportSpecList
	for nb != nil {
		nc := nb.ImportSpecList
		nb.ImportSpecList = na
		na = nb
		nb = nc
	}
	n.ImportSpecList = nil
	return na
}

func (n *ImportSpecList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ImportSpecList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ImportSpecList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.ImportSpec.Pos()
	case 1:
		return n.ImportSpecList.Pos()
	default:
		panic("internal error")
	}
}

// InterfaceMethodDecl represents data reduced by productions:
//
//	InterfaceMethodDecl:
//	        IDENTIFIER Signature
//	|       QualifiedIdent        // Case 1
type InterfaceMethodDecl struct {
	fileScope       *Scope
	resolutionScope *Scope // Where to search for case 1: QualifiedIdent.
	Case            int
	QualifiedIdent  *QualifiedIdent
	Signature       *Signature
	Token           xc.Token
}

func (n *InterfaceMethodDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *InterfaceMethodDecl) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *InterfaceMethodDecl) Pos() token.Pos {
	switch n.Case {
	case 1:
		return n.QualifiedIdent.Pos()
	case 0:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// InterfaceMethodDeclList represents data reduced by productions:
//
//	InterfaceMethodDeclList:
//	        InterfaceMethodDecl
//	|       InterfaceMethodDeclList ';' InterfaceMethodDecl  // Case 1
type InterfaceMethodDeclList struct {
	Case                    int
	InterfaceMethodDecl     *InterfaceMethodDecl
	InterfaceMethodDeclList *InterfaceMethodDeclList
	Token                   xc.Token
}

func (n *InterfaceMethodDeclList) reverse() *InterfaceMethodDeclList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.InterfaceMethodDeclList
	for nb != nil {
		nc := nb.InterfaceMethodDeclList
		nb.InterfaceMethodDeclList = na
		na = nb
		nb = nc
	}
	n.InterfaceMethodDeclList = nil
	return na
}

func (n *InterfaceMethodDeclList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *InterfaceMethodDeclList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *InterfaceMethodDeclList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.InterfaceMethodDecl.Pos()
	case 1:
		return n.InterfaceMethodDeclList.Pos()
	default:
		panic("internal error")
	}
}

// InterfaceType represents data reduced by productions:
//
//	InterfaceType:
//	        "interface" LBrace '}'
//	|       "interface" LBrace InterfaceMethodDeclList SemicolonOpt '}'  // Case 1
type InterfaceType struct {
	Type                    Type
	guard                   gate
	methods                 *Scope
	pkgPath                 int
	Case                    int
	InterfaceMethodDeclList *InterfaceMethodDeclList
	LBrace                  *LBrace
	SemicolonOpt            *SemicolonOpt
	Token                   xc.Token
	Token2                  xc.Token
}

func (n *InterfaceType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *InterfaceType) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *InterfaceType) Pos() token.Pos {
	return n.Token.Pos()
}

// LBrace represents data reduced by productions:
//
//	LBrace:
//	        BODY
//	|       '{'   // Case 1
type LBrace struct {
	Case  int
	Token xc.Token
}

func (n *LBrace) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *LBrace) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *LBrace) Pos() token.Pos {
	return n.Token.Pos()
}

// LBraceCompLitItem represents data reduced by productions:
//
//	LBraceCompLitItem:
//	        Expression
//	|       Expression ':' Expression          // Case 1
//	|       Expression ':' LBraceCompLitValue  // Case 2
//	|       LBraceCompLitValue                 // Case 3
type LBraceCompLitItem struct {
	Case               int
	Expression         *Expression
	Expression2        *Expression
	LBraceCompLitValue *LBraceCompLitValue
	Token              xc.Token
}

func (n *LBraceCompLitItem) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *LBraceCompLitItem) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *LBraceCompLitItem) Pos() token.Pos {
	switch n.Case {
	case 0, 1, 2:
		return n.Expression.Pos()
	case 3:
		return n.LBraceCompLitValue.Pos()
	default:
		panic("internal error")
	}
}

// LBraceCompLitItemList represents data reduced by productions:
//
//	LBraceCompLitItemList:
//	        LBraceCompLitItem
//	|       LBraceCompLitItemList ',' LBraceCompLitItem  // Case 1
type LBraceCompLitItemList struct {
	Case                  int
	LBraceCompLitItem     *LBraceCompLitItem
	LBraceCompLitItemList *LBraceCompLitItemList
	Token                 xc.Token
}

func (n *LBraceCompLitItemList) reverse() *LBraceCompLitItemList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.LBraceCompLitItemList
	for nb != nil {
		nc := nb.LBraceCompLitItemList
		nb.LBraceCompLitItemList = na
		na = nb
		nb = nc
	}
	n.LBraceCompLitItemList = nil
	return na
}

func (n *LBraceCompLitItemList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *LBraceCompLitItemList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *LBraceCompLitItemList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.LBraceCompLitItem.Pos()
	case 1:
		return n.LBraceCompLitItemList.Pos()
	default:
		panic("internal error")
	}
}

// LBraceCompLitValue represents data reduced by productions:
//
//	LBraceCompLitValue:
//	        LBrace '}'
//	|       LBrace LBraceCompLitItemList CommaOpt '}'  // Case 1
type LBraceCompLitValue struct {
	items                 int64
	Type                  Type
	Case                  int
	CommaOpt              *CommaOpt
	LBrace                *LBrace
	LBraceCompLitItemList *LBraceCompLitItemList
	Token                 xc.Token
}

func (n *LBraceCompLitValue) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *LBraceCompLitValue) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *LBraceCompLitValue) Pos() token.Pos {
	return n.LBrace.Pos()
}

// MapType represents data reduced by production:
//
//	MapType:
//	        "map" '[' Typ ']' Typ
type MapType struct {
	guard  gate
	Type   Type
	Token  xc.Token
	Token2 xc.Token
	Token3 xc.Token
	Typ    *Typ
	Typ2   *Typ
}

func (n *MapType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *MapType) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *MapType) Pos() token.Pos {
	return n.Token.Pos()
}

// Operand represents data reduced by productions:
//
//	Operand:
//	        '(' Expression ')'
//	|       '(' TypeLiteral ')'                // Case 1
//	|       BasicLiteral                       // Case 2
//	|       FuncType LBrace StatementList '}'  // Case 3
//	|       IDENTIFIER GenericArgumentsOpt     // Case 4
type Operand struct {
	Value               Value
	fileScope           *Scope
	resolutionScope     *Scope // Where to search for case 4: IDENTIFIER.
	BasicLiteral        *BasicLiteral
	Case                int
	Expression          *Expression
	FuncType            *FuncType
	GenericArgumentsOpt *GenericArgumentsOpt
	LBrace              *LBrace
	StatementList       *StatementList
	Token               xc.Token
	Token2              xc.Token
	TypeLiteral         *TypeLiteral
}

func (n *Operand) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Operand) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Operand) Pos() token.Pos {
	switch n.Case {
	case 2:
		return n.BasicLiteral.Pos()
	case 3:
		return n.FuncType.Pos()
	case 0, 1, 4:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// PackageClause represents data reduced by production:
//
//	PackageClause:
//	        "package" IDENTIFIER ';'
type PackageClause struct {
	Token  xc.Token
	Token2 xc.Token
	Token3 xc.Token
}

func (n *PackageClause) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *PackageClause) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *PackageClause) Pos() token.Pos {
	return n.Token.Pos()
}

// ParameterDecl represents data reduced by productions:
//
//	ParameterDecl:
//	        "..." Typ
//	|       IDENTIFIER "..." Typ  // Case 1
//	|       IDENTIFIER Typ        // Case 2
//	|       Typ                   // Case 3
type ParameterDecl struct {
	isParamName bool
	isVariadic  bool
	nm          xc.Token
	typ         *Typ
	Case        int
	Token       xc.Token
	Token2      xc.Token
	Typ         *Typ
}

func (n *ParameterDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ParameterDecl) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ParameterDecl) Pos() token.Pos {
	switch n.Case {
	case 0, 1, 2:
		return n.Token.Pos()
	case 3:
		return n.Typ.Pos()
	default:
		panic("internal error")
	}
}

// ParameterDeclList represents data reduced by productions:
//
//	ParameterDeclList:
//	        ParameterDecl
//	|       ParameterDeclList ',' ParameterDecl  // Case 1
type ParameterDeclList struct {
	Case              int
	ParameterDecl     *ParameterDecl
	ParameterDeclList *ParameterDeclList
	Token             xc.Token
}

func (n *ParameterDeclList) reverse() *ParameterDeclList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ParameterDeclList
	for nb != nil {
		nc := nb.ParameterDeclList
		nb.ParameterDeclList = na
		na = nb
		nb = nc
	}
	n.ParameterDeclList = nil
	return na
}

func (n *ParameterDeclList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ParameterDeclList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ParameterDeclList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.ParameterDecl.Pos()
	case 1:
		return n.ParameterDeclList.Pos()
	default:
		panic("internal error")
	}
}

// Parameters represents data reduced by productions:
//
//	Parameters:
//	        '(' ')'
//	|       '(' ParameterDeclList CommaOpt ')'  // Case 1
type Parameters struct {
	list              []*ParameterDecl
	Case              int
	CommaOpt          *CommaOpt
	ParameterDeclList *ParameterDeclList
	Token             xc.Token
	Token2            xc.Token
}

func (n *Parameters) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Parameters) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Parameters) Pos() token.Pos {
	return n.Token.Pos()
}

// PrimaryExpression represents data reduced by productions:
//
//	PrimaryExpression:
//	        Operand
//	|       CompLitType LBraceCompLitValue                                               // Case 1
//	|       PrimaryExpression '.' '(' "type" ')'                                         // Case 2
//	|       PrimaryExpression '.' '(' Typ ')'                                            // Case 3
//	|       PrimaryExpression '.' IDENTIFIER                                             // Case 4
//	|       PrimaryExpression '[' Expression ']'                                         // Case 5
//	|       PrimaryExpression '[' ExpressionOpt ':' ExpressionOpt ':' ExpressionOpt ']'  // Case 6
//	|       PrimaryExpression '[' ExpressionOpt ':' ExpressionOpt ']'                    // Case 7
//	|       PrimaryExpression Call                                                       // Case 8
//	|       PrimaryExpression CompLitValue                                               // Case 9
//	|       TypeLiteral '(' Expression CommaOpt ')'                                      // Case 10
type PrimaryExpression struct {
	Value              Value
	Call               *Call
	Case               int
	CommaOpt           *CommaOpt
	CompLitType        *CompLitType
	CompLitValue       *CompLitValue
	Expression         *Expression
	ExpressionOpt      *ExpressionOpt
	ExpressionOpt2     *ExpressionOpt
	ExpressionOpt3     *ExpressionOpt
	LBraceCompLitValue *LBraceCompLitValue
	Operand            *Operand
	PrimaryExpression  *PrimaryExpression
	Token              xc.Token
	Token2             xc.Token
	Token3             xc.Token
	Token4             xc.Token
	Typ                *Typ
	TypeLiteral        *TypeLiteral
}

func (n *PrimaryExpression) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *PrimaryExpression) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *PrimaryExpression) Pos() token.Pos {
	switch n.Case {
	case 1:
		return n.CompLitType.Pos()
	case 0:
		return n.Operand.Pos()
	case 2, 3, 4, 5, 6, 7, 8, 9:
		return n.PrimaryExpression.Pos()
	case 10:
		return n.TypeLiteral.Pos()
	default:
		panic("internal error")
	}
}

// Prologue represents data reduced by production:
//
//	Prologue:
//	        PackageClause ImportList
type Prologue struct {
	ImportList    *ImportList
	PackageClause *PackageClause
}

func (n *Prologue) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Prologue) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Prologue) Pos() token.Pos {
	return n.PackageClause.Pos()
}

// QualifiedIdent represents data reduced by productions:
//
//	QualifiedIdent:
//	        IDENTIFIER
//	|       IDENTIFIER '.' IDENTIFIER  // Case 1
type QualifiedIdent struct {
	Case   int
	Token  xc.Token
	Token2 xc.Token
	Token3 xc.Token
}

func (n *QualifiedIdent) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *QualifiedIdent) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *QualifiedIdent) Pos() token.Pos {
	return n.Token.Pos()
}

// Range represents data reduced by productions:
//
//	Range:
//	        ExpressionList '=' "range" Expression
//	|       ExpressionList ":=" "range" Expression  // Case 1
//	|       "range" Expression                      // Case 2
type Range struct {
	Case           int
	Expression     *Expression
	ExpressionList *ExpressionList
	Token          xc.Token
	Token2         xc.Token
}

func (n *Range) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Range) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Range) Pos() token.Pos {
	switch n.Case {
	case 0, 1:
		return n.ExpressionList.Pos()
	case 2:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// ReceiverOpt represents data reduced by productions:
//
//	ReceiverOpt:
//	        /* empty */
//	|       Parameters   // Case 1
type ReceiverOpt struct {
	Type            Type
	isPtr           bool
	nm              xc.Token
	resolutionScope *Scope
	Parameters      *Parameters
}

func (n *ReceiverOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ReceiverOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ReceiverOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Parameters.Pos()
}

// ResultOpt represents data reduced by productions:
//
//	ResultOpt:
//	        /* empty */
//	|       Parameters   // Case 1
//	|       Typ          // Case 2
type ResultOpt struct {
	Type       Type
	Case       int
	Parameters *Parameters
	Typ        *Typ
}

func (n *ResultOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ResultOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ResultOpt) Pos() token.Pos {
	switch n.Case {
	case 0:
		return 0
	case 1:
		return n.Parameters.Pos()
	case 2:
		return n.Typ.Pos()
	default:
		panic("internal error")
	}
}

// SelectStatement represents data reduced by production:
//
//	SelectStatement:
//	        "select" SwitchBody
type SelectStatement struct {
	SwitchBody *SwitchBody
	Token      xc.Token
}

func (n *SelectStatement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SelectStatement) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SelectStatement) Pos() token.Pos {
	return n.Token.Pos()
}

// SemicolonOpt represents data reduced by productions:
//
//	SemicolonOpt:
//	        /* empty */
//	|       ';'          // Case 1
type SemicolonOpt struct {
	Token xc.Token
}

func (n *SemicolonOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SemicolonOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SemicolonOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// Signature represents data reduced by production:
//
//	Signature:
//	        Parameters ResultOpt
type Signature struct {
	Type       Type
	Parameters *Parameters
	ResultOpt  *ResultOpt
}

func (n *Signature) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Signature) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Signature) Pos() token.Pos {
	return n.Parameters.Pos()
}

// SimpleStatement represents data reduced by productions:
//
//	SimpleStatement:
//	        Assignment
//	|       Expression                          // Case 1
//	|       Expression "--"                     // Case 2
//	|       Expression "++"                     // Case 3
//	|       ExpressionList ":=" ExpressionList  // Case 4
type SimpleStatement struct {
	Assignment      *Assignment
	Case            int
	Expression      *Expression
	ExpressionList  *ExpressionList
	ExpressionList2 *ExpressionList
	Token           xc.Token
}

func (n *SimpleStatement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SimpleStatement) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SimpleStatement) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.Assignment.Pos()
	case 1, 2, 3:
		return n.Expression.Pos()
	case 4:
		return n.ExpressionList.Pos()
	default:
		panic("internal error")
	}
}

// SimpleStatementOpt represents data reduced by productions:
//
//	SimpleStatementOpt:
//	        /* empty */
//	|       SimpleStatement  // Case 1
type SimpleStatementOpt struct {
	SimpleStatement *SimpleStatement
}

func (n *SimpleStatementOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SimpleStatementOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SimpleStatementOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.SimpleStatement.Pos()
}

// SliceType represents data reduced by production:
//
//	SliceType:
//	        '[' ']' Typ
type SliceType struct {
	guard  gate
	Type   Type
	Token  xc.Token
	Token2 xc.Token
	Typ    *Typ
}

func (n *SliceType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SliceType) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SliceType) Pos() token.Pos {
	return n.Token.Pos()
}

// Statement represents data reduced by productions:
//
//	Statement:
//	        /* empty */
//	|       Block             // Case 1
//	|       ConstDecl         // Case 2
//	|       TypeDecl          // Case 3
//	|       VarDecl           // Case 4
//	|       StatementNonDecl  // Case 5
//	|       error             // Case 6
type Statement struct {
	Block            *Block
	Case             int
	ConstDecl        *ConstDecl
	StatementNonDecl *StatementNonDecl
	Token            xc.Token
	TypeDecl         *TypeDecl
	VarDecl          *VarDecl
}

func (n *Statement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Statement) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Statement) Pos() token.Pos {
	switch n.Case {
	case 0:
		return 0
	case 1:
		return n.Block.Pos()
	case 2:
		return n.ConstDecl.Pos()
	case 5:
		return n.StatementNonDecl.Pos()
	case 6:
		return n.Token.Pos()
	case 3:
		return n.TypeDecl.Pos()
	case 4:
		return n.VarDecl.Pos()
	default:
		panic("internal error")
	}
}

// StatementList represents data reduced by productions:
//
//	StatementList:
//	        Statement
//	|       StatementList ';' Statement  // Case 1
type StatementList struct {
	Case          int
	Statement     *Statement
	StatementList *StatementList
	Token         xc.Token
}

func (n *StatementList) reverse() *StatementList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.StatementList
	for nb != nil {
		nc := nb.StatementList
		nb.StatementList = na
		na = nb
		nb = nc
	}
	n.StatementList = nil
	return na
}

func (n *StatementList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *StatementList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *StatementList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.Statement.Pos()
	case 1:
		if p := n.StatementList.Pos(); p != 0 {
			return p
		}

		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// StatementNonDecl represents data reduced by productions:
//
//	StatementNonDecl:
//	        "break" IdentifierOpt
//	|       "continue" IdentifierOpt    // Case 1
//	|       "defer" Expression          // Case 2
//	|       "fallthrough"               // Case 3
//	|       ForStatement                // Case 4
//	|       "go" Expression             // Case 5
//	|       "goto" IDENTIFIER           // Case 6
//	|       IDENTIFIER ':' Statement    // Case 7
//	|       IfStatement                 // Case 8
//	|       "return" ExpressionListOpt  // Case 9
//	|       SelectStatement             // Case 10
//	|       SimpleStatement             // Case 11
//	|       SwitchStatement             // Case 12
type StatementNonDecl struct {
	Case              int
	Expression        *Expression
	ExpressionListOpt *ExpressionListOpt
	ForStatement      *ForStatement
	IdentifierOpt     *IdentifierOpt
	IfStatement       *IfStatement
	SelectStatement   *SelectStatement
	SimpleStatement   *SimpleStatement
	Statement         *Statement
	SwitchStatement   *SwitchStatement
	Token             xc.Token
	Token2            xc.Token
}

func (n *StatementNonDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *StatementNonDecl) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *StatementNonDecl) Pos() token.Pos {
	switch n.Case {
	case 4:
		return n.ForStatement.Pos()
	case 8:
		return n.IfStatement.Pos()
	case 10:
		return n.SelectStatement.Pos()
	case 11:
		return n.SimpleStatement.Pos()
	case 12:
		return n.SwitchStatement.Pos()
	case 0, 1, 2, 3, 5, 6, 7, 9:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// StructFieldDecl represents data reduced by productions:
//
//	StructFieldDecl:
//	        '*' QualifiedIdent TagOpt
//	|       IdentifierList Typ TagOpt          // Case 1
//	|       QualifiedIdent TagOpt              // Case 2
//	|       '(' QualifiedIdent ')' TagOpt      // Case 3
//	|       '(' '*' QualifiedIdent ')' TagOpt  // Case 4
//	|       '*' '(' QualifiedIdent ')' TagOpt  // Case 5
type StructFieldDecl struct {
	Case           int
	IdentifierList *IdentifierList
	QualifiedIdent *QualifiedIdent
	TagOpt         *TagOpt
	Token          xc.Token
	Token2         xc.Token
	Token3         xc.Token
	Typ            *Typ
}

func (n *StructFieldDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *StructFieldDecl) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *StructFieldDecl) Pos() token.Pos {
	switch n.Case {
	case 1:
		return n.IdentifierList.Pos()
	case 2:
		return n.QualifiedIdent.Pos()
	case 0, 3, 4, 5:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// StructFieldDeclList represents data reduced by productions:
//
//	StructFieldDeclList:
//	        StructFieldDecl
//	|       StructFieldDeclList ';' StructFieldDecl  // Case 1
type StructFieldDeclList struct {
	Case                int
	StructFieldDecl     *StructFieldDecl
	StructFieldDeclList *StructFieldDeclList
	Token               xc.Token
}

func (n *StructFieldDeclList) reverse() *StructFieldDeclList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.StructFieldDeclList
	for nb != nil {
		nc := nb.StructFieldDeclList
		nb.StructFieldDeclList = na
		na = nb
		nb = nc
	}
	n.StructFieldDeclList = nil
	return na
}

func (n *StructFieldDeclList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *StructFieldDeclList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *StructFieldDeclList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.StructFieldDecl.Pos()
	case 1:
		return n.StructFieldDeclList.Pos()
	default:
		panic("internal error")
	}
}

// StructType represents data reduced by productions:
//
//	StructType:
//	        "struct" LBrace '}'
//	|       "struct" LBrace StructFieldDeclList SemicolonOpt '}'  // Case 1
type StructType struct {
	Type                Type
	fields              *Scope
	guard               gate
	pkgPath             int
	Case                int
	LBrace              *LBrace
	SemicolonOpt        *SemicolonOpt
	StructFieldDeclList *StructFieldDeclList
	Token               xc.Token
	Token2              xc.Token
}

func (n *StructType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *StructType) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *StructType) Pos() token.Pos {
	return n.Token.Pos()
}

// SwitchBody represents data reduced by productions:
//
//	SwitchBody:
//	        BODY '}'
//	|       BODY SwitchCaseList '}'  // Case 1
type SwitchBody struct {
	Case           int
	SwitchCaseList *SwitchCaseList
	Token          xc.Token
	Token2         xc.Token
}

func (n *SwitchBody) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SwitchBody) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SwitchBody) Pos() token.Pos {
	return n.Token.Pos()
}

// SwitchCase represents data reduced by productions:
//
//	SwitchCase:
//	        "case" ArgumentList ':'
//	|       "case" ArgumentList '=' Expression ':'   // Case 1
//	|       "case" ArgumentList ":=" Expression ':'  // Case 2
//	|       "default" ':'                            // Case 3
//	|       "case" error                             // Case 4
//	|       "default" error                          // Case 5
type SwitchCase struct {
	ArgumentList *ArgumentList
	Case         int
	Expression   *Expression
	Token        xc.Token
	Token2       xc.Token
	Token3       xc.Token
}

func (n *SwitchCase) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SwitchCase) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SwitchCase) Pos() token.Pos {
	return n.Token.Pos()
}

// SwitchCaseBlock represents data reduced by production:
//
//	SwitchCaseBlock:
//	        SwitchCase StatementList
type SwitchCaseBlock struct {
	StatementList *StatementList
	SwitchCase    *SwitchCase
}

func (n *SwitchCaseBlock) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SwitchCaseBlock) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SwitchCaseBlock) Pos() token.Pos {
	return n.SwitchCase.Pos()
}

// SwitchCaseList represents data reduced by productions:
//
//	SwitchCaseList:
//	        SwitchCaseBlock
//	|       SwitchCaseList SwitchCaseBlock  // Case 1
type SwitchCaseList struct {
	Case            int
	SwitchCaseBlock *SwitchCaseBlock
	SwitchCaseList  *SwitchCaseList
}

func (n *SwitchCaseList) reverse() *SwitchCaseList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.SwitchCaseList
	for nb != nil {
		nc := nb.SwitchCaseList
		nb.SwitchCaseList = na
		na = nb
		nb = nc
	}
	n.SwitchCaseList = nil
	return na
}

func (n *SwitchCaseList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *SwitchCaseList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SwitchCaseList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.SwitchCaseBlock.Pos()
	case 1:
		return n.SwitchCaseList.Pos()
	default:
		panic("internal error")
	}
}

// SwitchHeader represents data reduced by productions:
//
//	SwitchHeader:
//	        SimpleStatementOpt
//	|       SimpleStatementOpt ';'                                                       // Case 1
//	|       SimpleStatementOpt ';' Expression                                            // Case 2
//	|       SimpleStatementOpt ';' IDENTIFIER ":=" PrimaryExpression '.' '(' "type" ')'  // Case 3
type SwitchHeader struct {
	Case               int
	Expression         *Expression
	PrimaryExpression  *PrimaryExpression
	SimpleStatementOpt *SimpleStatementOpt
	Token              xc.Token
	Token2             xc.Token
	Token3             xc.Token
	Token4             xc.Token
	Token5             xc.Token
	Token6             xc.Token
	Token7             xc.Token
}

func (n *SwitchHeader) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SwitchHeader) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SwitchHeader) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.SimpleStatementOpt.Pos()
	case 1, 2, 3:
		if p := n.SimpleStatementOpt.Pos(); p != 0 {
			return p
		}

		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// SwitchStatement represents data reduced by production:
//
//	SwitchStatement:
//	        "switch" SwitchHeader SwitchBody
type SwitchStatement struct {
	SwitchBody   *SwitchBody
	SwitchHeader *SwitchHeader
	Token        xc.Token
}

func (n *SwitchStatement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SwitchStatement) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SwitchStatement) Pos() token.Pos {
	return n.Token.Pos()
}

// TagOpt represents data reduced by productions:
//
//	TagOpt:
//	        /* empty */
//	|       STRING_LIT   // Case 1
type TagOpt struct {
	stringValue stringValue
	Token       xc.Token
}

func (n *TagOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *TagOpt) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TagOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// TopLevelDecl represents data reduced by productions:
//
//	TopLevelDecl:
//	        ConstDecl
//	|       FuncDecl          // Case 1
//	|       TypeDecl          // Case 2
//	|       VarDecl           // Case 3
//	|       StatementNonDecl  // Case 4
//	|       error             // Case 5
type TopLevelDecl struct {
	Case             int
	ConstDecl        *ConstDecl
	FuncDecl         *FuncDecl
	StatementNonDecl *StatementNonDecl
	Token            xc.Token
	TypeDecl         *TypeDecl
	VarDecl          *VarDecl
}

func (n *TopLevelDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *TopLevelDecl) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TopLevelDecl) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.ConstDecl.Pos()
	case 1:
		return n.FuncDecl.Pos()
	case 4:
		return n.StatementNonDecl.Pos()
	case 5:
		return n.Token.Pos()
	case 2:
		return n.TypeDecl.Pos()
	case 3:
		return n.VarDecl.Pos()
	default:
		panic("internal error")
	}
}

// TopLevelDeclList represents data reduced by productions:
//
//	TopLevelDeclList:
//	        /* empty */
//	|       TopLevelDeclList TopLevelDecl ';'  // Case 1
type TopLevelDeclList struct {
	Token            xc.Token
	TopLevelDecl     *TopLevelDecl
	TopLevelDeclList *TopLevelDeclList
}

func (n *TopLevelDeclList) reverse() *TopLevelDeclList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.TopLevelDeclList
	for nb != nil {
		nc := nb.TopLevelDeclList
		nb.TopLevelDeclList = na
		na = nb
		nb = nc
	}
	n.TopLevelDeclList = nil
	return na
}

func (n *TopLevelDeclList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *TopLevelDeclList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TopLevelDeclList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	if p := n.TopLevelDeclList.Pos(); p != 0 {
		return p
	}

	return n.TopLevelDecl.Pos()
}

// Typ represents data reduced by productions:
//
//	Typ:
//	        '(' Typ ')'
//	|       '*' Typ                             // Case 1
//	|       ArrayType                           // Case 2
//	|       ChanType                            // Case 3
//	|       FuncType                            // Case 4
//	|       InterfaceType                       // Case 5
//	|       MapType                             // Case 6
//	|       QualifiedIdent GenericArgumentsOpt  // Case 7
//	|       SliceType                           // Case 8
//	|       StructType                          // Case 9
type Typ struct {
	Type                Type
	fileScope           *Scope
	guard               gate
	resolutionScope     *Scope // Where to search for case 7: QualifiedIdent.
	ArrayType           *ArrayType
	Case                int
	ChanType            *ChanType
	FuncType            *FuncType
	GenericArgumentsOpt *GenericArgumentsOpt
	InterfaceType       *InterfaceType
	MapType             *MapType
	QualifiedIdent      *QualifiedIdent
	SliceType           *SliceType
	StructType          *StructType
	Token               xc.Token
	Token2              xc.Token
	Typ                 *Typ
}

func (n *Typ) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Typ) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Typ) Pos() token.Pos {
	switch n.Case {
	case 2:
		return n.ArrayType.Pos()
	case 3:
		return n.ChanType.Pos()
	case 4:
		return n.FuncType.Pos()
	case 5:
		return n.InterfaceType.Pos()
	case 6:
		return n.MapType.Pos()
	case 7:
		return n.QualifiedIdent.Pos()
	case 8:
		return n.SliceType.Pos()
	case 9:
		return n.StructType.Pos()
	case 0, 1:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// TypeDecl represents data reduced by productions:
//
//	TypeDecl:
//	        "type" '(' ')'
//	|       "type" '(' TypeSpecList SemicolonOpt ')'  // Case 1
//	|       "type" TypeSpec                           // Case 2
type TypeDecl struct {
	Case         int
	SemicolonOpt *SemicolonOpt
	Token        xc.Token
	Token2       xc.Token
	Token3       xc.Token
	TypeSpec     *TypeSpec
	TypeSpecList *TypeSpecList
}

func (n *TypeDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *TypeDecl) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TypeDecl) Pos() token.Pos {
	return n.Token.Pos()
}

// TypeList represents data reduced by productions:
//
//	TypeList:
//	        Typ
//	|       TypeList ',' Typ  // Case 1
type TypeList struct {
	Case     int
	Token    xc.Token
	Typ      *Typ
	TypeList *TypeList
}

func (n *TypeList) reverse() *TypeList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.TypeList
	for nb != nil {
		nc := nb.TypeList
		nb.TypeList = na
		na = nb
		nb = nc
	}
	n.TypeList = nil
	return na
}

func (n *TypeList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *TypeList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TypeList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.Typ.Pos()
	case 1:
		return n.TypeList.Pos()
	default:
		panic("internal error")
	}
}

// TypeLiteral represents data reduced by productions:
//
//	TypeLiteral:
//	        '*' TypeLiteral
//	|       ArrayType        // Case 1
//	|       ChanType         // Case 2
//	|       FuncType         // Case 3
//	|       InterfaceType    // Case 4
//	|       MapType          // Case 5
//	|       SliceType        // Case 6
//	|       StructType       // Case 7
type TypeLiteral struct {
	guard         gate
	Type          Type
	ArrayType     *ArrayType
	Case          int
	ChanType      *ChanType
	FuncType      *FuncType
	InterfaceType *InterfaceType
	MapType       *MapType
	SliceType     *SliceType
	StructType    *StructType
	Token         xc.Token
	TypeLiteral   *TypeLiteral
}

func (n *TypeLiteral) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *TypeLiteral) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TypeLiteral) Pos() token.Pos {
	switch n.Case {
	case 1:
		return n.ArrayType.Pos()
	case 2:
		return n.ChanType.Pos()
	case 3:
		return n.FuncType.Pos()
	case 4:
		return n.InterfaceType.Pos()
	case 5:
		return n.MapType.Pos()
	case 6:
		return n.SliceType.Pos()
	case 7:
		return n.StructType.Pos()
	case 0:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// TypeSpec represents data reduced by production:
//
//	TypeSpec:
//	        IDENTIFIER GenericParametersOpt Typ
type TypeSpec struct {
	GenericParametersOpt *GenericParametersOpt
	Token                xc.Token
	Typ                  *Typ
}

func (n *TypeSpec) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *TypeSpec) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TypeSpec) Pos() token.Pos {
	return n.Token.Pos()
}

// TypeSpecList represents data reduced by productions:
//
//	TypeSpecList:
//	        TypeSpec
//	|       TypeSpecList ';' TypeSpec  // Case 1
type TypeSpecList struct {
	Case         int
	Token        xc.Token
	TypeSpec     *TypeSpec
	TypeSpecList *TypeSpecList
}

func (n *TypeSpecList) reverse() *TypeSpecList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.TypeSpecList
	for nb != nil {
		nc := nb.TypeSpecList
		nb.TypeSpecList = na
		na = nb
		nb = nc
	}
	n.TypeSpecList = nil
	return na
}

func (n *TypeSpecList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *TypeSpecList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TypeSpecList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.TypeSpec.Pos()
	case 1:
		return n.TypeSpecList.Pos()
	default:
		panic("internal error")
	}
}

// UnaryExpression represents data reduced by productions:
//
//	UnaryExpression:
//	        '!' UnaryExpression
//	|       '&' UnaryExpression   // Case 1
//	|       '*' UnaryExpression   // Case 2
//	|       '+' UnaryExpression   // Case 3
//	|       '-' UnaryExpression   // Case 4
//	|       '^' UnaryExpression   // Case 5
//	|       "<-" UnaryExpression  // Case 6
//	|       PrimaryExpression     // Case 7
type UnaryExpression struct {
	Value             Value
	Case              int
	PrimaryExpression *PrimaryExpression
	Token             xc.Token
	UnaryExpression   *UnaryExpression
}

func (n *UnaryExpression) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *UnaryExpression) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *UnaryExpression) Pos() token.Pos {
	switch n.Case {
	case 7:
		return n.PrimaryExpression.Pos()
	case 0, 1, 2, 3, 4, 5, 6:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// VarDecl represents data reduced by productions:
//
//	VarDecl:
//	        "var" '(' ')'
//	|       "var" '(' VarSpecList SemicolonOpt ')'  // Case 1
//	|       "var" VarSpec                           // Case 2
type VarDecl struct {
	Case         int
	SemicolonOpt *SemicolonOpt
	Token        xc.Token
	Token2       xc.Token
	Token3       xc.Token
	VarSpec      *VarSpec
	VarSpecList  *VarSpecList
}

func (n *VarDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *VarDecl) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *VarDecl) Pos() token.Pos {
	return n.Token.Pos()
}

// VarSpec represents data reduced by productions:
//
//	VarSpec:
//	        IdentifierList '=' ExpressionList
//	|       IdentifierList Typ                     // Case 1
//	|       IdentifierList Typ '=' ExpressionList  // Case 2
type VarSpec struct {
	Case           int
	ExpressionList *ExpressionList
	IdentifierList *IdentifierList
	Token          xc.Token
	Typ            *Typ
}

func (n *VarSpec) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *VarSpec) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *VarSpec) Pos() token.Pos {
	return n.IdentifierList.Pos()
}

// VarSpecList represents data reduced by productions:
//
//	VarSpecList:
//	        VarSpec
//	|       VarSpecList ';' VarSpec  // Case 1
type VarSpecList struct {
	Case        int
	Token       xc.Token
	VarSpec     *VarSpec
	VarSpecList *VarSpecList
}

func (n *VarSpecList) reverse() *VarSpecList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.VarSpecList
	for nb != nil {
		nc := nb.VarSpecList
		nb.VarSpecList = na
		na = nb
		nb = nc
	}
	n.VarSpecList = nil
	return na
}

func (n *VarSpecList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *VarSpecList) String() string {
	return PrettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *VarSpecList) Pos() token.Pos {
	switch n.Case {
	case 0:
		return n.VarSpec.Pos()
	case 1:
		return n.VarSpecList.Pos()
	default:
		panic("internal error")
	}
}
